<!DOCTYPE html>
<html>
<head>
    <title>Webash</title>
    <meta charset="UTF-8" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.1.0/lib/xterm.min.js"></script>
    <link
        href="https://cdn.jsdelivr.net/npm/xterm@5.1.0/css/xterm.min.css"
        rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-attach@0.8.0/lib/xterm-addon-attach.min.js"></script>
    <style type="text/css">
        /* Ensure no margins and full height for HTML and body */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #0e1017;
        }

        #terminal .terminal {
            padding: 8px;
            overflow-y: auto;
        }

        .xterm-screen {
            height: 100% !important;
            width: 100% !important;
        }

        .xterm-viewport {
            overflow-y: hidden !important;
            height: 100% !important;
        }

        .terminal.xterm.xterm-dom-renderer-owner-1, .xterm-rows {
            height: 100% !important;
            width: 100% !important;
        }

        .xterm-rows.xterm-focus, .terminal.xterm.xterm-dom-renderer-owner-1.focus {
            height: 100% !important;
            width: 100% !important;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>
    <script>

        const http_protocol = window.location.protocol;
        var host = window.location.host;
        const API_BASE = `${http_protocol}//${host}/api/v1`;

        // Terminal
        const term = new window.Terminal({
            cursorBlink: true,
            fontSize: 16,
            rendererType: isMobile() ? 'dom' : 'canvas',
        });

        if (!isMobile()) {
            document.querySelector("#terminal").style.height = '100vh';
        }

        // Utility to get stored tokens from localStorage
        const getLocalTokens = () => {
            const tokens = JSON.parse(localStorage.getItem('tokens'));
            return tokens || { access: null, refresh: null };
        };

        // Utility to store tokens in localStorage
        const storeTokens = (tokens) => {
            localStorage.setItem('tokens', JSON.stringify(tokens));
        };

        // Utility to clear tokens from localStorage
        const clearTokens = () => {
            localStorage.removeItem('tokens');
        };

        async function getInputCode(term) {
            return new Promise((resolve) => {
                let codeBuffer = "";

                const onDataHandler = term.onData((data) => {
                    if (data === '\r') { // Enter key
                        onDataHandler.dispose(); // –û—Ç–º–µ–Ω—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
                        if (/^\d{6}$/.test(codeBuffer)) {
                            resolve(codeBuffer.trim()); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤–≤–µ–¥–µ–Ω–Ω—ã–π –∫–æ–¥
                        } else {
                            resolve(null);
                        }
                    } else if (data === '\u007F') { // Backspace key
                        if (codeBuffer.length > 0) {
                            codeBuffer = codeBuffer.slice(0, -1); // Remove last character
                            term.write("\b \b"); // Handle backspace in the terminal
                        } else {
                            term.write(''); // Prevent deletion when buffer is empty
                        }
                    } else if (/^\d$/.test(data) && codeBuffer.length < 6) {
                        codeBuffer += data;
                        term.write(data);
                    }
                });
            });
        }

        // Function to refresh tokens
        async function refreshTokens(refreshToken) {
            try {
                const response = await fetch(`${API_BASE}/user/token-refresh`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ refresh: refreshToken })
                });

                if (response.ok) {
                    const data = await response.json();
                    storeTokens(data.tokens);
                    return { success: true, tokens: data.tokens };
                } else {
                    const error = await response.text();
                    return { success: false, error };
                }
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        // Function to get tokens using code
        async function getTokensWithCode(code) {
            try {
                const response = await fetch(`${API_BASE}/user/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ otp_code: code })
                });

                if (response.ok) {
                    const data = await response.json();
                    storeTokens(data.tokens);
                    term.write('\r\n')
                    return { success: true, tokens: data.tokens };
                } else {
                    const error = await response.json();
                    return { success: false, error: error.detail };
                }
            } catch (error) {
                return { success: false, error: error.message };
            }
        }

        async function getTokens(term) {
            term.write('Salom!üëã  @WeBashBot telegram bot orqali parol kodni oling.');
            let response = null
            while (true) {
                term.write('\r\nParol kodni kiriting (olti xonalik son): ');
                let code = await getInputCode(term);
                if (!code) {
                    continue
                }
                response = await getTokensWithCode(code);
                if (!response.success) {
                    continue;
                };
                break;
            };
            return response.tokens;
        };

        async function getAccessToken(term) {
            let { access, refresh } = getLocalTokens();
            if (!refresh) {
                let tokens = await getTokens(term);
                return tokens.access;
            }

            let responseTokensData = await refreshTokens(refresh);
            if (responseTokensData.success) {
                access = responseTokensData.tokens.access;
                return access;
            };

            let tokens = await getTokens(term);
            return tokens.access;
        };

        function isMobile() {
            return /Mobile|iP(hone|od)|Android|BlackBerry|IEMobile|Kindle|Silk-Accelerated|(hpw|web)OS|Opera M(obi|ini)|(tablet|ipad|playbook|silk)|(android(?!.*mobi))/.test(
                navigator.userAgent
            );
        }

        window.onload = async function () {

            let terminalContainer = document.getElementById("terminal")
            term.open(terminalContainer);
            term.focus();

            let access = await getAccessToken(term);

            const isSecure = window.location.protocol === "https:";
            const protocol = isSecure ? "wss://" : "ws://";
            const path = "/api/v1/console/ws";
            const params = new URLSearchParams({
                token: access,
            });
            console.log(host)

            if (!host) {
                host = '0.0.0.0:8000'
            }
            const ws = new WebSocket(`${protocol}${host}${path}?${params}`);
            const attachAddon = new AttachAddon.AttachAddon(ws);
            term.loadAddon(attachAddon);

            ws.onclose = () => {
                term.write('[Connection closed]');
                term.options.cursorBlink = false;
                term.blur();
            }

            // Function to calculate and set terminal dimensions
            function fitTerminal() {
                const containerStyle = getComputedStyle(terminalContainer);
                const containerWidth = parseFloat(containerStyle.width);
                const containerHeight = parseFloat(containerStyle.height);

                const row = document.querySelector('.xterm-rows > div')
                const char = row.querySelector('span')

                const charHeight = parseFloat(getComputedStyle(row).height)
                const charWidth = parseFloat(getComputedStyle(char).width)

                if (charWidth && charHeight) {
                    const cols = Math.floor(containerWidth / charWidth);
                    const rows = Math.floor(containerHeight / charHeight);

                    // Resize the terminal
                    term.resize(cols, rows);
                }
            }

            const checkRendered = setInterval(() => {
                if (
                    document.querySelector(".xterm-rows span")
                ) {
                    clearInterval(checkRendered); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
                    console.log("–¢–µ—Ä–º–∏–Ω–∞–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≥—Ä—É–∂–µ–Ω!");

                    fitTerminal()

                    // Resize observer to dynamically update terminal size
                    const resizeObserver = new ResizeObserver(() => {
                        fitTerminal();
                    });
                    resizeObserver.observe(terminalContainer);
                }
                }, 50); // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–µ 50 –º—Å
        };

    </script>
</body>
</html>
